import React, { useState, useEffect, useMemo } from 'react';
import { RaceEvent, OperationalLogisticsDay, OperationalTiming, AppState, EventTransportLeg, TransportDirection, TransportMode, MealDay, OperationalTimingCategory, Rider, StaffRole } from '../../types';
import { MealDay as MealDayEnum } from '../../types'; // For dayName dropdown
import ActionButton from '../../components/ActionButton';
import TrashIcon from '../../components/icons/TrashIcon';
import InformationCircleIcon from '../../components/icons/InformationCircleIcon';
import PencilIcon from '../../components/icons/PencilIcon';
import TruckIcon from '../../components/icons/TruckIcon';
import TrophyIcon from '../../components/icons/TrophyIcon';
import CakeIcon from '../../components/icons/CakeIcon';
import PlusCircleIcon from '../../components/icons/PlusCircleIcon';
import HandRaisedIcon from '../../components/icons/HandRaisedIcon';


// --- TIME PARSING UTILITIES ---

// Parses a time-of-day string (e.g., "14h30", "8:15") into minutes from midnight.
const parseTimeOfDayToMinutes = (timeStr: string): number | null => {
    if (!timeStr) return null;
    const cleanedTime = timeStr.trim().split('-')[0].trim();
    const parts = cleanedTime.replace('h', ':').split(':');
    
    if (parts.length > 0) {
        const hours = parseInt(parts[0], 10);
        const minutes = (parts.length > 1 && parts[1]) ? parseInt(parts[1], 10) : 0;
        if (!isNaN(hours) && !isNaN(minutes)) {
            return hours * 60 + minutes;
        }
    }
    return null;
};

// Parses a duration string (e.g., "1h30", "45min") into total minutes.
const parseDurationToMinutes = (timeStr: string): number | null => {
    if (!timeStr) return null;
    let remainingStr = timeStr.toLowerCase().trim();
    let totalMinutes = 0;
    
    const hourMatch = remainingStr.match(/^(\d+(?:\.\d+)?)\s*h/);
    if (hourMatch) {
        totalMinutes += parseFloat(hourMatch[1]) * 60;
        remainingStr = remainingStr.replace(hourMatch[0], '').trim();
    }
    
    const minMatch = remainingStr.match(/^(\d+)\s*(?:min|m)?/);
    if (minMatch && minMatch[1]) {
        totalMinutes += parseInt(minMatch[1], 10);
    }

    return totalMinutes > 0 ? totalMinutes : null;
};

// Formats total minutes from midnight into a time-of-day string (e.g., "14h30").
const formatMinutesToTimeOfDay = (totalMinutes: number): string => {
    if (totalMinutes < 0) totalMinutes += 24 * 60;
    const hours = Math.floor(totalMinutes / 60);
    const minutes = Math.round(totalMinutes % 60);
    return `${hours}h${minutes.toString().padStart(2, '0')}`;
};

// Subtracts a duration in minutes from a time-of-day string.
const subtractDurationFromTimeOfDay = (timeOfDayStr: string, minutesToSubtract: number): string | null => {
    const initialMinutes = parseTimeOfDayToMinutes(timeOfDayStr);
    if (initialMinutes === null) return null;
    const resultMinutes = initialMinutes - minutesToSubtract;
    return formatMinutesToTimeOfDay(resultMinutes);
};


interface EventOperationalLogisticsTabProps {
  event: RaceEvent;
  updateEvent: (updatedEventData: Partial<RaceEvent>) => void;
  appState: AppState;
}

interface AutoTiming extends OperationalTiming {
    targetMealDay: MealDay;
}

const categoryStyles: Record<OperationalTimingCategory, { icon: React.FC<any>; color: string }> = {
    [OperationalTimingCategory.TRANSPORT]: { icon: TruckIcon, color: 'text-blue-500' },
    [OperationalTimingCategory.COURSE]: { icon: TrophyIcon, color: 'text-green-500' },
    [OperationalTimingCategory.REPAS]: { icon: CakeIcon, color: 'text-orange-500' },
    [OperationalTimingCategory.DIVERS]: { icon: InformationCircleIcon, color: 'text-gray-500' },
    [OperationalTimingCategory.MASSAGE]: { icon: HandRaisedIcon, color: 'text-teal-500' },
};

const EventOperationalLogisticsTab: React.FC<EventOperationalLogisticsTabProps> = ({ event, updateEvent, appState }) => {
  const [logistics, setLogistics] = useState<OperationalLogisticsDay[]>([]);
  const [isEditing, setIsEditing] = useState(false);

  useEffect(() => {
    setLogistics(structuredClone(event.operationalLogistics || []));
  }, [event.operationalLogistics]);

  const getOccupantName = (occupantId: string, type: 'rider' | 'staff'): string => {
    const person = type === 'rider'
      ? appState.riders.find(r => r.id === occupantId)
      : appState.staff.find(s => s.id === occupantId);
    return person ? `${person.firstName} ${person.lastName}` : 'Inconnu';
  };

  const autoGeneratedTimings = useMemo(() => {
    const timings: AutoTiming[] = [];
    const dayMap: Record<number, MealDayEnum> = { 0: MealDayEnum.DIMANCHE, 1: MealDayEnum.LUNDI, 2: MealDayEnum.MARDI, 3: MealDayEnum.MERCREDI, 4: MealDayEnum.JEUDI, 5: MealDayEnum.VENDREDI, 6: MealDayEnum.SAMEDI };
    const getTargetMealDay = (dateStr: string | undefined): MealDay | null => {
        if (!dateStr) return null;
        try {
            return dayMap[new Date(`${dateStr}T12:00:00Z`).getUTCDay()];
        } catch { return null; }
    };
    
    appState.eventTransportLegs.filter(leg => leg.eventId === event.id).forEach(leg => {
        if (leg.departureDate && leg.departureTime) {
            const targetDay = getTargetMealDay(leg.departureDate);
            if (targetDay) {
                timings.push({
                    id: `auto-transport-depart-${leg.id}`,
                    time: leg.departureTime,
                    description: `Départ ${leg.personName || 'Transport'} (${leg.direction}) de ${leg.departureLocation || 'N/A'}`,
                    isAutoGenerated: true,
                    targetMealDay: targetDay,
                    category: OperationalTimingCategory.TRANSPORT
                });
            }
        }
        if (leg.arrivalDate && leg.arrivalTime) {
            const targetDay = getTargetMealDay(leg.arrivalDate);
            if (targetDay) {
                timings.push({
                    id: `auto-transport-arrivee-${leg.id}`,
                    time: leg.arrivalTime,
                    description: `Arrivée ${leg.personName || 'Transport'} (${leg.direction}) à ${leg.arrivalLocation || 'N/A'}`,
                    isAutoGenerated: true,
                    targetMealDay: targetDay,
                    category: OperationalTimingCategory.TRANSPORT
                });
            }
        }
        // Add intermediate stops to the timeline
        if (leg.intermediateStops && leg.intermediateStops.length > 0) {
            leg.intermediateStops.forEach(stop => {
                const targetDay = getTargetMealDay(stop.date);
                if (targetDay && stop.time) {
                    const stopTypeLabel = stop.stopType === 'pickup' ? 'Ramassage' : stop.stopType === 'dropoff' ? 'Dépose' : 'Étape';
                    const personsConcerned = stop.persons.map(p => getOccupantName(p.id, p.type)).join(', ');
                    let description = `${stopTypeLabel} à ${stop.location}`;
                    if(personsConcerned) {
                        description += ` (${personsConcerned})`;
                    }
                    if(stop.notes) {
                        description += ` - ${stop.notes}`;
                    }

                    timings.push({
                        id: `auto-stop-${stop.id}`,
                        time: stop.time,
                        description: description,
                        isAutoGenerated: true,
                        targetMealDay: targetDay,
                        category: OperationalTimingCategory.TRANSPORT
                    });
                }
            });
        }
    });

    const { raceInfo } = event;
    if (raceInfo) {
      const mainEventDay = getTargetMealDay(event.date);
      if (raceInfo.permanenceTime) {
        const targetDay = getTargetMealDay(raceInfo.permanenceDate) || mainEventDay;
        if (targetDay) timings.push({ id: 'auto-permanence', time: raceInfo.permanenceTime, description: 'Permanence', isAutoGenerated: true, targetMealDay: targetDay, category: OperationalTimingCategory.COURSE });
      }
      if (raceInfo.reunionDSTime) {
        const targetDay = getTargetMealDay(raceInfo.reunionDSDate) || getTargetMealDay(raceInfo.permanenceDate) || mainEventDay;
        if (targetDay) timings.push({ id: 'auto-reunionDS', time: raceInfo.reunionDSTime, description: "Réunion Directeurs Sportifs", isAutoGenerated: true, targetMealDay: targetDay, category: OperationalTimingCategory.COURSE });
      }
      if (mainEventDay) {
          if (raceInfo.departReelTime) {
              timings.push({ id: 'auto-departReel', time: raceInfo.departReelTime, description: 'Départ Réel', isAutoGenerated: true, targetMealDay: mainEventDay, category: OperationalTimingCategory.COURSE });
              const mealTime = subtractDurationFromTimeOfDay(raceInfo.departReelTime, 180);
              if (mealTime) timings.push({ id: 'auto-repas', time: mealTime, description: 'Repas', isAutoGenerated: true, targetMealDay: mainEventDay, category: OperationalTimingCategory.REPAS });
          }
          if (raceInfo.presentationTime) {
              timings.push({ id: 'auto-presentation', time: raceInfo.presentationTime, description: 'Présentation des équipes', isAutoGenerated: true, targetMealDay: mainEventDay, category: OperationalTimingCategory.COURSE });
              const arrivalOnSiteTime = subtractDurationFromTimeOfDay(raceInfo.presentationTime, 30);
              if (arrivalOnSiteTime) {
                  timings.push({ id: 'auto-arriveeSite', time: arrivalOnSiteTime, description: 'Arrivée sur site', isAutoGenerated: true, targetMealDay: mainEventDay, category: OperationalTimingCategory.COURSE });
              }
          }
          if (raceInfo.departFictifTime) timings.push({ id: 'auto-departFictif', time: raceInfo.departFictifTime, description: 'Départ Fictif', isAutoGenerated: true, targetMealDay: mainEventDay, category: OperationalTimingCategory.COURSE });
          if (raceInfo.arriveePrevueTime) {
              const arrivalDay = getTargetMealDay(event.endDate || event.date);
              if (arrivalDay) {
                timings.push({ id: 'auto-arrivee', time: raceInfo.arriveePrevueTime, description: 'Arrivée Prévue', isAutoGenerated: true, targetMealDay: arrivalDay, category: OperationalTimingCategory.COURSE });
              }
          }
      }
    }
    
    // Add hotel departure time
    const arrivalOnSiteTiming = timings.find(t => t.id === 'auto-arriveeSite');
    if (arrivalOnSiteTiming) {
        const accommodation = appState.eventAccommodations.find(a => a.eventId === event.id && !a.isStopover);
        if (accommodation?.travelTimeToStart) {
            const travelDurationMinutes = parseDurationToMinutes(accommodation.travelTimeToStart);
            if (travelDurationMinutes !== null) {
                const totalTravelMinutesWithMargin = Math.ceil(travelDurationMinutes * 1.1);
                const hotelDepartureTime = subtractDurationFromTimeOfDay(arrivalOnSiteTiming.time, totalTravelMinutesWithMargin);
                if (hotelDepartureTime) {
                    timings.push({
                        id: 'auto-departHotel',
                        time: hotelDepartureTime,
                        description: 'Départ Hôtel',
                        isAutoGenerated: true,
                        targetMealDay: arrivalOnSiteTiming.targetMealDay,
                        category: OperationalTimingCategory.TRANSPORT
                    });
                }
            }
        }
    }

    return timings;
  }, [event, appState.eventTransportLegs, appState.eventAccommodations]);

  const mainEventDayName = useMemo(() => {
    const dayMap: Record<number, MealDayEnum> = { 0: MealDayEnum.DIMANCHE, 1: MealDayEnum.LUNDI, 2: MealDayEnum.MARDI, 3: MealDayEnum.MERCREDI, 4: MealDayEnum.JEUDI, 5: MealDayEnum.VENDREDI, 6: MealDayEnum.SAMEDI };
    if (!event.date) return null;
    try {
        return dayMap[new Date(`${event.date}T12:00:00Z`).getUTCDay()];
    } catch { return null; }
  }, [event.date]);

  const displayLogistics = useMemo(() => {
    const mergedDays: Record<string, OperationalLogisticsDay> = {};

    logistics.forEach(day => {
        mergedDays[day.dayName] = structuredClone(day);
    });

    autoGeneratedTimings.forEach(autoTiming => {
        const dayName = autoTiming.targetMealDay;
        const isAlreadyPresent = logistics.some(day => day.dayName === dayName && day.keyTimings.some(t => t.id === autoTiming.id));

        if (!isAlreadyPresent) {
            if (!mergedDays[dayName]) {
                mergedDays[dayName] = { id: `day-${dayName}`, dayName, keyTimings: [] };
            }
            mergedDays[dayName].keyTimings.push({ ...autoTiming, isOverridden: false });
        }
    });

    let finalDays = Object.values(mergedDays);
    finalDays.forEach(day => day.keyTimings.sort((a, b) => (parseTimeOfDayToMinutes(a.time) ?? 9999) - (parseTimeOfDayToMinutes(b.time) ?? 9999)));

    // Grouping Logic
    const groupedDays = finalDays.map(day => {
        const newKeyTimings: OperationalTiming[] = [];
        const processedIndices = new Set<number>();

        for (let i = 0; i < day.keyTimings.length; i++) {
            if (processedIndices.has(i)) continue;

            const currentTiming = day.keyTimings[i];
            const isGroupable = currentTiming.category === OperationalTimingCategory.TRANSPORT && (currentTiming.description.startsWith('Départ') || currentTiming.description.startsWith('Arrivée'));

            if (isGroupable) {
                const matches = currentTiming.description.match(/^(Départ|Arrivée)\s(.*?)\s\((.*?)\)\s(de|à)\s(.+)/);
                if (matches) {
                    const type = matches[1];
                    const location = matches[5];
                    const time = currentTiming.time;

                    const groupPeers = [currentTiming];
                    const groupVehicles = [matches[2]];

                    for (let j = i + 1; j < day.keyTimings.length; j++) {
                        const nextTiming = day.keyTimings[j];
                        if (nextTiming.time !== time) break;

                        if (nextTiming.category === OperationalTimingCategory.TRANSPORT) {
                            const nextMatches = nextTiming.description.match(/^(Départ|Arrivée)\s(.*?)\s\((.*?)\)\s(de|à)\s(.+)/);
                            if (nextMatches && nextMatches[1] === type && nextMatches[5] === location) {
                                groupPeers.push(nextTiming);
                                groupVehicles.push(nextMatches[2]);
                                processedIndices.add(j);
                            }
                        }
                    }

                    if (groupPeers.length > 1) {
                        const newDescription = `${type} ${groupVehicles.join(', ')} (${groupPeers[0].description.match(/\((.*?)\)/)?.[1] || ''}) ${type === 'Départ' ? 'de' : 'à'} ${location}`;
                        newKeyTimings.push({ ...currentTiming, id: `grouped-${currentTiming.id}`, description: newDescription });
                        processedIndices.add(i);
                    } else {
                        newKeyTimings.push(currentTiming);
                    }
                } else {
                     newKeyTimings.push(currentTiming);
                }
            } else {
                newKeyTimings.push(currentTiming);
            }
        }
        return { ...day, keyTimings: newKeyTimings };
    });

    return groupedDays.sort((a, b) => Object.values(MealDayEnum).indexOf(a.dayName) - Object.values(MealDayEnum).indexOf(b.dayName));
  }, [logistics, autoGeneratedTimings]);
  
  const handleTimingChange = (dayId: string, dayNameForCreation: MealDay, timing: OperationalTiming, field: keyof OperationalTiming, value: any) => {
    setLogistics(currentLogistics => {
        const updatedLogistics = structuredClone(currentLogistics);
        let dayIndex = updatedLogistics.findIndex(d => d.id === dayId);

        if (dayIndex === -1) {
            const newDay: OperationalLogisticsDay = { id: dayId, dayName: dayNameForCreation, keyTimings: [] };
            updatedLogistics.push(newDay);
            dayIndex = updatedLogistics.length - 1; 
        }
        
        let dayToUpdate = updatedLogistics[dayIndex];
        let timingIndex = dayToUpdate.keyTimings.findIndex(t => t.id === timing.id);
        
        let processedValue = value;
        if (field === 'order') {
          processedValue = value === '' ? undefined : parseInt(value, 10);
        }

        if (timingIndex > -1) {
          // Editing existing timing
          (dayToUpdate.keyTimings[timingIndex] as any)[field] = processedValue;
          if (dayToUpdate.keyTimings[timingIndex].isAutoGenerated) {
              dayToUpdate.keyTimings[timingIndex].isOverridden = true;
          }
        } else {
          // Adding a new timing
          const newTiming = { ...timing, [field]: processedValue, isOverridden: timing.isAutoGenerated, id: timing.id || Date.now().toString() };
          dayToUpdate.keyTimings.push(newTiming as OperationalTiming);
        }

        return updatedLogistics;
    });
};


  const handleDayNameChange = (dayId: string, newDayName: MealDay) => {
    setLogistics(prev => prev.map(day => day.id === dayId ? { ...day, dayName: newDayName } : day));
  };

  const addDay = () => setLogistics(prev => [...prev, { id: Date.now().toString(), dayName: MealDayEnum.AUTRE, keyTimings: [] }]);
  const removeDay = (dayIdToRemove: string) => setLogistics(prev => prev.filter(day => day.id !== dayIdToRemove));
  
  const addTimingToDay = (dayId: string) => {
    const day = displayLogistics.find(d => d.id === dayId);
    if (!day) return;
    handleTimingChange(dayId, day.dayName, {id: Date.now().toString(), time: '', description: '', isAutoGenerated: false, category: OperationalTimingCategory.DIVERS}, 'description', '');
  };

  const removeTimingFromDay = (dayId: string, timingId: string) => {
    setLogistics(prev => prev.map(day => {
      if (day.id === dayId) {
        return { ...day, keyTimings: day.keyTimings.filter(t => t.id !== timingId) };
      }
      return day;
    }));
  };

  const handleSave = () => {
    updateEvent({ operationalLogistics: logistics });
    setIsEditing(false);
  };

  const handleCancel = () => {
    setLogistics(structuredClone(event.operationalLogistics || []));
    setIsEditing(false);
  };
  
  const lightInputClass = "block w-full px-2 py-1 border rounded-md shadow-sm sm:text-sm bg-white text-gray-900 border-gray-300 placeholder-gray-400 focus:ring-blue-500 focus:border-blue-500 text-xs";
  
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h3 className="text-xl font-semibold text-gray-700">Logistique Opérationnelle (Timing par Jour)</h3>
        {!isEditing && <ActionButton onClick={() => setIsEditing(true)} variant="primary">Modifier Timings</ActionButton>}
      </div>

      {isEditing ? (
        <div className="space-y-4">
          {displayLogistics.map(day => {
            return (
            <div key={day.id} className="p-3 border rounded-md bg-gray-50">
              <div className="flex items-center mb-2">
                <select value={day.dayName} onChange={(e) => handleDayNameChange(day.id, e.target.value as MealDay)} className={`${lightInputClass} font-semibold !w-auto mr-2`}>
                  {Object.values(MealDayEnum).map(d => <option key={d} value={d}>{d}</option>)}
                </select>
                {day.dayName === mainEventDayName && <span className="text-xs font-bold text-red-600 bg-red-100 px-2 py-0.5 rounded-full">JOUR J</span>}
                <ActionButton type="button" variant="danger" size="sm" onClick={() => removeDay(day.id)} className="ml-auto !p-1"><TrashIcon className="w-4 h-4"/></ActionButton>
              </div>
              
               <div className="grid grid-cols-12 gap-2 mb-1 text-xs font-medium text-gray-500 px-1">
                <div className="col-span-2">Catégorie</div>
                <div className="col-span-2">Heure</div>
                <div className="col-span-7">Description / Personnes</div>
                <div className="col-span-1"></div>
              </div>

              {day.keyTimings.map(timing => {
                const isMassage = timing.category === OperationalTimingCategory.MASSAGE;
                return (
                  <div key={timing.id} className="grid grid-cols-12 gap-2 mb-1 items-center">
                    <div className="col-span-2">
                        <select
                            value={timing.category || OperationalTimingCategory.DIVERS}
                            onChange={e => handleTimingChange(day.id, day.dayName, timing, 'category', e.target.value)}
                            className={lightInputClass}
                            disabled={timing.isAutoGenerated && !timing.isOverridden}
                        >{Object.values(OperationalTimingCategory).map(cat => (<option key={cat} value={cat}>{cat}</option>))}</select>
                    </div>
                    <div className="col-span-2">
                        <input type="text" value={timing.time} onChange={e => handleTimingChange(day.id, day.dayName, timing, 'time', e.target.value)} placeholder="ex: 14h" className={lightInputClass} />
                    </div>
                    
                    {isMassage ? (
                      <>
                        <div className="col-span-2">
                            <select
                                value={timing.personId || ''}
                                onChange={e => handleTimingChange(day.id, day.dayName, timing, 'personId', e.target.value)}
                                className={lightInputClass}
                            >
                                <option value="">- Coureur -</option>
                                {appState.riders.map(r => <option key={r.id} value={r.id}>{`${r.firstName} ${r.lastName}`}</option>)}
                            </select>
                        </div>
                        <div className="col-span-2">
                            <select
                                value={timing.masseurId || ''}
                                onChange={e => handleTimingChange(day.id, day.dayName, timing, 'masseurId', e.target.value)}
                                className={lightInputClass}
                            >
                                <option value="">- Masseur -</option>
                                {appState.staff
                                    .filter(s => s.role === StaffRole.KINE || s.role === StaffRole.ASSISTANT)
                                    .map(s => <option key={s.id} value={s.id}>{`${s.firstName} ${s.lastName}`}</option>)}
                            </select>
                        </div>
                        <div className="col-span-1">
                            <input type="number" value={timing.order ?? ''} onChange={e => handleTimingChange(day.id, day.dayName, timing, 'order', e.target.value)} placeholder="Ordre" className={lightInputClass}/>
                        </div>
                      </>
                    ) : null}
                    
                    <div className={isMassage ? 'col-span-2' : 'col-span-7'}>
                        <input type="text" value={timing.description} onChange={e => handleTimingChange(day.id, day.dayName, timing, 'description', e.target.value)} placeholder="Description" className={lightInputClass} />
                    </div>
                    
                    <div className="col-span-1">
                        {!timing.isAutoGenerated && <ActionButton type="button" variant="danger" size="sm" onClick={() => removeTimingFromDay(day.id, timing.id)} className="!p-1 w-full"><TrashIcon className="w-4 h-4 mx-auto"/></ActionButton>}
                    </div>
                  </div>
                )
              })}
              <ActionButton type="button" variant="secondary" size="sm" onClick={() => addTimingToDay(day.id)} className="mt-2 text-xs" icon={<PlusCircleIcon className="w-3 h-3 mr-1"/>}>
                Ajouter Timing Manuel
              </ActionButton>
            </div>
            )
          })}
          <div className="text-center mt-4 pt-4 border-t">
            <ActionButton type="button" variant="secondary" onClick={addDay} icon={<PlusCircleIcon className="w-4 h-4 mr-1"/>}>
                Ajouter une journée
            </ActionButton>
          </div>
          <div className="flex justify-end space-x-3 pt-4 border-t mt-6">
            <ActionButton type="button" variant="secondary" onClick={handleCancel}>Annuler</ActionButton>
            <ActionButton type="button" onClick={handleSave}>Sauvegarder Timings</ActionButton>
          </div>
        </div>
      ) : (
        displayLogistics.length > 0 ? (
          displayLogistics.map(day => (
            <div key={day.id} className="p-3 mb-3 border rounded-md bg-gray-50">
              <h4 className="text-md font-semibold text-gray-700 mb-1 flex items-center">
                  {day.dayName}
                  {day.dayName === mainEventDayName && <span className="ml-2 text-xs font-bold text-red-600 bg-red-100 px-2 py-0.5 rounded-full">JOUR J</span>}
              </h4>
              <ul className="space-y-1">
                {day.keyTimings.map(timing => {
                  const category = timing.category || OperationalTimingCategory.DIVERS;
                  const Icon = categoryStyles[category].icon;
                  const color = categoryStyles[category].color;
                  const title = timing.isAutoGenerated ? (timing.isOverridden ? 'Automatique, modifié' : 'Automatique') : 'Manuel';
                  
                  let description = timing.description || "N/A";
                  if (category === OperationalTimingCategory.MASSAGE && timing.personId) {
                      const riderName = getOccupantName(timing.personId, 'rider');
                      description = `${description}: ${riderName} ${timing.order ? `(#${timing.order})` : ''}`;
                      if (timing.masseurId) {
                          const masseurName = getOccupantName(timing.masseurId, 'staff');
                          description += ` par ${masseurName}`;
                      }
                  }

                  return (
                    <li key={timing.id} className="text-sm flex items-center">
                       <span title={title}>
                        {timing.isOverridden ? 
                            <PencilIcon className="w-4 h-4 mr-2 flex-shrink-0 text-purple-600"/> :
                            <Icon className={`w-4 h-4 mr-2 flex-shrink-0 ${color}`}/>
                        }
                       </span>
                      <span className="font-semibold w-24">{timing.time || "N/A"}:</span>
                      <span className="flex-1">{description}</span>
                    </li>
                  )
                })}
              </ul>
            </div>
          ))
        ) : <p className="text-gray-500 italic">Aucune logistique opérationnelle définie.</p>
      )}

      {!isEditing && (
         <div className="mt-6 pt-4 border-t">
            <h4 className="text-md font-semibold text-gray-700 mb-2 flex items-center"><InformationCircleIcon className="w-5 h-5 mr-2 text-blue-500"/>Légende</h4>
            <ul className="text-xs text-gray-600 space-y-1">
                {Object.entries(categoryStyles).map(([cat, style]) => {
                    const Icon = style.icon;
                    return (
                         <li key={cat} className="flex items-center"><Icon className={`w-4 h-4 mr-2 flex-shrink-0 ${style.color}`}/> Timing de catégorie '{cat}'.</li>
                    );
                })}
                <li className="flex items-center"><PencilIcon className="w-4 h-4 mr-2 text-purple-600"/> Timing automatique qui a été modifié manuellement.</li>
            </ul>
        </div>
      )}
    </div>
  );
};

export default EventOperationalLogisticsTab;